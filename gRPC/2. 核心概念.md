# 核心概念、架构和生命周期

对关键 gRPC 概念的介绍，以及 gRPC 架构和 RPC 生命周期的概述。

不熟悉 gRPC？请先阅读 [gRPC 入门](https://grpc.io/docs/what-is-grpc/introduction/)。有关特定语言的详细信息，请参阅你选择的语言的快速入门、教程和参考文档。

### 概述

#### 服务定义

与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以通过参数和返回类型远程调用的方法。默认情况下，gRPC 使用[协议缓冲区](https://developers.google.com/protocol-buffers)作为接口定义语言 (IDL)，用于描述服务接口和 payload 消息的结构。如果需要，可以使用其他替代方案。

```proto
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

gRPC 允许你定义四类服务方法：

- 一元 RPC，客户端向服务器发送单个请求并返回单个响应，就像普通的函数调用一样。

  ```proto
  rpc SayHello(HelloRequest) returns (HelloResponse);
  ```

- 服务器流式 RPC，客户端向服务器发送请求并获取流以读取一系列消息。客户端从返回的流中读取，直到流中没有消息。gRPC 保证单个 RPC 调用中的消息排序。

  ```proto
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
  ```

- 客户端流式 RPC，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成写入消息，它等待服务器读取它们并返回其响应。gRPC 再次保证单个 RPC 调用中的消息排序。

  ```proto
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
  ```

- 双向流式 RPC，其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序进行读写：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。

  ```proto
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
  ```

在下面的[RPC 生命周期](https://grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle)部分你可以了解到有关不同类型 RPC 的更多信息 。

### 使用 API

从 `.proto` 中定义服务开始，gRPC 提供了 protocol buffer 编译器插件方便你生成客户端和服务端代码。gRPC 用户在客户端调用这些 API ，并在服务端实现对应的 API 。

- 在服务端，实现服务声明的方法并启动一个 gRPC 服务去处理客户端请求。gRPC 基础设施解码传入请求、执行服务方法并编码服务响应。
- 在客户端，有一个被称作 *stub*（对于某些语言，首选术语是*client*）的本地对象，实现了对应的方法。客户端可以像调用本地对象一样调用这些方法，将调用的参数组装在适当的 protocol buffer 消息类型中 - gRPC 负责将请求发送到服务器并返回服务器的协议缓冲区响应。

### 同步 vs 异步

在服务器响应到达之前阻塞的同步 RPC 调用是最接近 RPC 所追求的过程调用抽象。另一方面，网络本质上是异步的，在多数情况下，在不阻塞当前线程下启动 RPC 是很有用的。

大多数语言中的 gRPC 编程 API 都有同步和异步两种风格。你可以在每种语言的教程和参考文档中找到更多信息（完整的参考文档即将推出）。

### RPC 生命周期

在本节中，你将仔细了解当 gRPC 客户端调用 gRPC 服务器方法时会发生什么。有关完整的实现详细信息，请参阅特定语言的页面。

#### 一元RPC

首先考虑最简单的 RPC 类型即客户端发送单个请求并返回单个响应。

1. 一旦客户端调用了存根方法，服务器就会收到通知：RPC 已经被调用，其中包含客户端的[元数据](https://www.grpc.io/docs/what-is-grpc/core-concepts/#metadata) 、方法名称和指定的[截止日期（](https://www.grpc.io/docs/what-is-grpc/core-concepts/#deadlines)如果指定了）。
2. 服务器可以立即返回初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。
3. 一旦服务器收到客户端的请求消息，它就会执行创建和填充响应所需的任何工作。然后将响应（如果成功）连同状态详细信息（状态码和可选状态消息）和可选的尾随元数据一起返回给客户端。
4. 如果响应状态为OK，则客户端得到响应，客户端完成了调用。

#### 服务器流式RPC

服务器流式 RPC 类似于一元 RPC，不同之处在于服务器返回消息流以响应客户端的请求。发送完所有消息后，服务器的状态详细信息（状态码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。一旦客户端拥有服务器的所有消息，它就完成了。

#### 客户端流式 RPC

客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器用一条消息（连同状态详细信息和可选的尾随元数据）进行响应，通常但并非必定是在它收到所有客户端的消息之后。

#### 双向流式RPC

在双向流式 RPC 中，调用由调用方法的客户端唤起，服务器接收客户端元数据、方法名称和截止日期。服务器可以选择返回初始元数据或等待客户端开始流式传输消息。

客户端和服务器端流处理是特定于应用程序的。由于两个流是独立的，客户端和服务器可以按任意顺序读写消息。例如，服务器可以等到收到所有客户端的消息后再写入消息，或者服务器和客户端可以使用“ping-pong”模式——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。

#### 截止日期/超时

gRPC 允许客户端指定在 RPC 因`DEADLINE_EXCEEDED`错误终止之前 RPC完成的等待时长。在服务器端，服务器可以查询特定的 RPC 是否超时，以及计算还剩下多少时间来完成 RPC调用。

指定截止日期或超时是特定于语言的：一些语言 API 根据超时（持续时间）工作，而某些语言 API 根据截止日期（固定时间点）工作，也可能没有默认截止日期。

#### RPC 终止

在 gRPC 中，客户端和服务器都对调用的成功做出独立和本地的判断，它们的结论可能不一致。这意味着，例如，你可能有一个 RPC 在服务器端成功完成（“我已经发送了我所有的响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务器在客户端发送其所有请求之前决定完成响应也是有可能的。

#### 取消 RPC

客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，不再进行进一步的工作。

> #### 警告
> 取消之前所做的更改不会回滚。

#### 元数据

元数据是键值对列表形式的特定 RPC 调用的信息（例如[身份验证详细信息](https://www.grpc.io/docs/guides/auth/)），其中键是字符串，值通常是字符串，也可以是二进制数据。元数据对 gRPC 本身是不透明的——它允许客户端提供与服务器调用相关的信息，反之亦然。

对元数据的访问取决于语言。

#### 通道

gRPC 通道提供到指定主机和端口上的 gRPC 服务器的连接。它在创建客户端存根时使用。客户端可以指定通道参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。通道具有状态，包括`connected`和`idle`。

gRPC 如何处理关闭通道取决于语言。某些语言还允许查询通道状态。
